## Timeout (Тайм-аут)

Шаблон Timeout (Тайм-аут) позволяет процессу прекратить ожидание ответа, когда станет очевидно, что его можно вообще не получить.
Применимость
Первое из заблуждений распределенных вычислений гласит: «сеть надежна»,
и небезосновательно. Коммутаторы могут выйти из строя, маршрутизаторы
и межсетевые экраны могут быть неправильно настроены; пакеты теряются.
Даже если ваша сеть работает безупречно, не всякая служба спроектирована
настолько идеально, чтобы гарантировать значимый и своевременный ответ – или вообще какой-либо ответ – в случае сбоя.

Шаблон Timeout (Тайм-аут) предлагает распространенное решение этой
дилеммы, и он настолько прост, что его вообще едва ли можно квалифицировать как шаблон: если вызов службы или функции выполняется дольше
ожидаемого, вызывающий код просто... перестает ждать.
Но не путайте «простой» или «обычный» с «бесполезный». Напротив, повсеместное распространение стратегии тайм-аута свидетельствует о ее полезности. Разумное использование тайм-аутов может обеспечить хорошую
изоляцию сбоев, предотвратить каскадные сбои и снизить вероятность того,
что проблема в нижестоящем ресурсе станет вашей проблемой.

Компоненты
Этот шаблон включает следующие компоненты:
    Client
Клиент, обращающийся к SlowFunction.
    SlowFunction
Функция, возвращающая ответ, необходимый клиенту, и выполняющаяся
очень долго.
    Timeout
Функция-обертка вокруг SlowFunction, которая реализует логику тайм-аута

## Реализация
Реализовать тайм-аут на языке Go можно несколькими способами, но наиболее идиоматический – использовать возможности пакета context. См. раздел
«Пакет context» выше.
В идеальном случае долго выполняющаяся функция принимает параметр
context.Context. В такой ситуации вам останется только передать ей экземпляр Context, инициированный функцией context.WithTimeout:
    ctx := context.Background()
    ctxt, cancel := context.WithTimeout(ctx, 10 * time.Second)
    defer cancel()
        result, err := SomeFunction(ctxt)
Однако в реальности, особенно при использовании сторонних библиотек,
не всегда есть возможность рефакторинга, чтобы организовать передачу
экземпляра Context. В таких случаях лучшим вариантом может стать обертывание вызова функции так, чтобы он учитывал контекст Context.

Например, представьте, что у вас есть долго выполняющаяся функция, которая не только не принимает экземпляра Context, но и находится в стороннем пакете. Если клиент Client будет вызывать SlowFunction непосредственно,
ему придется ждать завершения функции, если это вообще произойдет. И как
быть в этом случае?

Функцию SlowFunction можно вызвать в  сопрограмме. Это позволит получить возвращаемый результат, если функция завершит работу в течение
приемлемого периода времени, и продолжить двигаться дальше, если этого
не случится.
Для этого можно использовать несколько инструментов, которые мы видели раньше: context.Context – для организации тайм-аута, каналы – для передачи результатов и select – чтобы обработать событие, которое произойдет
первым